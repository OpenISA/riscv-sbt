===
OiCombinePass
===
- combine load large immediates - ABSENT in RISC-V STB
- combine GEP+ShadowMemory - ABSENT


===
OiInstTranslate
===
- FinishFunction
    - IREmitter: CleanRegs, FixEntryBB, FixBBTerminators
    - ABSENT
- FinishModule
    - IREmitter::ProcessIndirectJumps
    - ABSENT
- HandleAluSrcOperand
    - Reg: load from local, mark as read
    - Imm: resolve relocation. Handle function address
    SBT:
    - MAYBE need to mark as read as well?
    - TODO better handling of function address
- HandleMemOperand
    - resolve relocation and map to shadow memory
    - DONE
- HandleAluDstOperand
    - get reg and mark as written
    - MAYBE
- HandleCallTarget
    - IREmitter::HandleLocalCall
    - OR handle libc call
    - DONE
- HandleBranchTarget
    - set target address and create BB
    - DONE
- printInstruction - main method
    - handle operands
    - add first instruction to map
    - JUMP: br
    - BRANCH: cond br
    - JAL: HandleCallTarget (IREmmiter::HandleLocalCall)
    - JALR: IREmmiter: HandleFunctionExitPoint/AddIndirectCall/HandleFunctionEntryPoint
    - IJMP: IREmmiter: AddIndirectJump to a dummy instruction
    - DONE


===
OiIREmitter
===
AbiLocals - save only those regs required by the ABI
NoLocals - use global variables only
OneRegion - whole program in one function
OptimizeStack
AggrOptimizeStack
NoShadow - avoid adding shadow image offset to every memory access

- CleanRegs - seems to remove unused loads/stores to registers that are not
used, but that the compiler can't optimize out.
- MAYBE check if needed

- ProcessIndirectJumps
    - for each relocation in .text:
        - offset = rel.offset + PatchedSecAddr
        - TargetAddr = rel.sym.addr + ShadowImage[offset] + TextOffset
        - CodePtrs.insert(TargetAddr)
        - if TargetAddr matches function addr: add patch: offset,
                                                          BB[TargetAddr]
        - IndDests.add(BB)
        - IndDestsAddrs.add(TargetAddr)

    - for each indirect jump:
        - try to find a jump table:
            - found: create a switch with possible destinations
            - not found: indirect br to all possible BBs in function
              (IndDests)

    - for each indirect call: call through pointer
- TODO need to implement this on SBT

- StartFunction
    - build local reg file
    - TODO need to implement local reg file
- StartMainFunction
    - InsertStartupCode
    - DONE in parts
- HandleFunctionEntryPoint - sync local reg file with global one
    - TODO need to implement this
- HandleFunctionExitPoint - sync global reg file with local one
    - TODO need to implement this
- FixEntryBB - fix function entry point, to the one with no predecessors
    - MAYBE is this needed on SBT?
- FixBBTerminators
    - CreateUnreachable on BBs with no terminators
    - erase empty BBs
    - MAYBE is this needed on SBT?
- BuildReturns
    - on function returns, create an indirect br, with call sites as
      possible destinations
    - MAYBE is this needed? SBT uses LLVM return on most cases
- HandleBackEdge
    - get back BB, possibly splitting an existing one
    - DONE


===
RelocationReader
===

Resolves relocations

- ResolveAllDataRelocations
    - for all relocations pointing to .data:
        - replace the value pointing to data by:
            - common symbol value, if relocation name matches the name of a
              common symbol:
                - BSS: symbol value = ELF symbol address
                - common: symbol value = current TotalSize, that is
                                         incremented next
                - IREmitter: adjusts every common symbol:
                    - value += CommonSectionAddress
                    - (CommonSectionAddress = ShadowSize)
            - other symbols: add section address to original symbol's address
    - .text relocations are performed by ProcessIndirectJumps

    - DONE seems to be done on SBT

===
SBTUtils
===

Convert register numbers from LLVM to OpenISA and vice-versa
- DONE

- GetELFOffset(section): get offset of section inside the ELF image
    - DONE
- GetCommonSymbolsList: get all .bss and common symbols from ELF object
    - DONE in another way


===
StringRefMemoryObject
===

Convenience class to extract bytes from a StringRef
- probably unneeded


===
SyscallsIface
===

Generate code to call libc functions.
- DONE in another way


===
staticbt
===

StackSize - default = 300B

- OptimizeAndWriteBitcode
    - createVerifierPass
    - createPromoteMemoryToRegisterPass
    - new OiCombinePass
    - createInstructionCombiningPass
    - createGVNPass
    - createCFGSimplificationPass
    - WriteBitcodeToFile
    - MAYBE need to optimize in SBT

- DisassembleObject
    - get target, its disassembler, reg info, asm info, etc...
    - create a new OiInstTranslate obj
    - for each text section:
        - read section symbols
        - for each symbol:
            - create a new function, beginning at symbol address and ending at
              the next symbol
            - for each instruction:
                - disassemble it
                - translate it (using OiInstTranlate)
    - OptimizeAndWriteBitcode
    - TODO translate multiple objects

- DumpObject
    - prints some stuff and calls DisassembleObject

- DumpArchive
    - iterate through each contained object calling DumpObject on each

- DumpInput
    - read file and call DumpArchive or DumpObject

- main
    - init LLVM targets
    - parse command line
    - for each input file:
        - call DumpInput


===
openisa
===

build.sh:
    - build binutils + LLVM OpenISA + newlib
    - download SPEC
    - download ARM cross-compiler
    - install SPEC and ARM compiler
    - build mibench (build_all_x86.sh)
    - build SPEC (build_all_x86.sh)

run.sh:
    - source env.sh
    - cd openisa/spec/testes-x86/measure_x86.sh

mibench/build_all_x86.sh:
    - for each selected benchmark:
        - cd to bench dir
        - for opts in -oneregion, -nolocals, (locals), -abi-locals:
            - skip cjpeg and djpeg in -oneregion mode
            - SBTOPT="-optimize $opts" make
            - copy binaries to testes-x86/bin



OpenISA
-------

# .c -> x86

clang -target x86_64-unknown-linux-gnu -O3 -mllvm -disable-llvm-optzns -m32 -emit-llvm -c dijkstra_large.c -o dijkstra_large.bc

llvm-link dijkstra_large.bc2 -o dijkstra_large-nat.bc

opt -O3 dijkstra_large-nat.bc -o dijkstra_large-nat.bc
opt -O3 dijkstra_large-nat.bc -o dijkstra_large-nat.bc

llc -relocation-model=static -O3 -march=x86 -mattr=avx2 dijkstra_large-nat.bc -o dijkstra_large-nat-x86.s

clang -target x86_64-unknown-linux-gnu -m32 -g dijkstra_large-nat-x86.s -o dijkstra_large-nat-x86 -lm


# .c -> oi.o

clang -target mipsel-unknown-linux -emit-llvm -c --sysroot=/home/luporl/dd/git/openisa/sbt-sysheaders -O3 -mllvm -disable-llvm-optzns dijkstra_large.c -o dijkstra_large.bc

llvm-link dijkstra_large.bc -o dijkstra_large.bc

opt -O3 dijkstra_large.bc -o dijkstra_large.bc

llc -relocation-model=static -O3 -march=mipsel dijkstra_large.bc -o dijkstra_large.s

llvm-mc -triple mipsel-unknown-linux -assemble -filetype=obj -o=dijkstra_large-oi.o dijkstra_large.s


# oi.o -> oi-x86

static-bt -target=x86 -optimize -oneregion -stacksize 4000 dijkstra_large-oi.o -o=dijkstra_large-oi.bc

opt -O3 dijkstra_large-oi.bc -o dijkstra_large-oi.bc

llc -relocation-model=static -O3 -march=x86 -mattr=avx2 dijkstra_large-oi.bc -o dijkstra_large-oi-x86.s

clang -target x86_64-unknown-linux-gnu -m32 -g dijkstra_large-oi-x86.s -o dijkstra_large-oi-x86 -lm

sbtpass2 dijkstra_large-oi-x86


# repeat with: static-bt -nolocals / "" (globals) / -abi-locals


RISC-V
------

# .c -> x86

clang --target=x86_64-unknown-linux-gnu -m32 -emit-llvm -c -O3 -mllvm -disable-llvm-optzns dijkstra_large.c -o x86-dijkstra_large.bc

llvm-dis x86-dijkstra_large.bc -o x86-dijkstra_large.ll
opt -O3 x86-dijkstra_large.bc -o x86-dijkstra_large.opt.bc
llvm-dis x86-dijkstra_large.opt.bc -o x86-dijkstra_large.opt.ll
opt -O3 x86-dijkstra_large.opt.bc -o x86-dijkstra_large.opt2.bc
llvm-dis x86-dijkstra_large.opt2.bc -o x86-dijkstra_large.opt2.ll

llc -relocation-model=static -O3 -march=x86 -mattr=avx2 x86-dijkstra_large.opt2.bc -o x86-dijkstra_large.s

# assembling and linking with GNU as/ld, because these are also used with
# RISC-V, as LLVM can't assemble and link RISC-V code yet.

x86_64-linux-gnu-as --32 -o x86-dijkstra_large.o -c x86-dijkstra_large.s

x86_64-linux-gnu-ld -m elf_i386 -o x86-dijkstra_large /usr/lib32/crt1.o /usr/lib32/crti.o x86-dijkstra_large.o /usr/lib32/libc.a /usr/lib/gcc/x86_64-linux-gnu/4.9.2/32/libgcc.a /usr/lib/gcc/x86_64-linux-gnu/4.9.2/32/libgcc_eh.a /usr/lib32/libc.a /usr/lib32/crtn.o


# .c -> rv32.o

clang --target=riscv -mriscv=RV32IMAFD -emit-llvm -c -O3 -mllvm -disable-llvm-optzns dijkstra_large.c -o rv32-dijkstra_large.bc

llvm-dis rv32-dijkstra_large.bc -o rv32-dijkstra_large.ll
opt -O3 rv32-dijkstra_large.bc -o rv32-dijkstra_large.opt.bc
llvm-dis rv32-dijkstra_large.opt.bc -o rv32-dijkstra_large.opt.ll

llc -relocation-model=static -O3 -march=riscv -mcpu=RV32IMAFD rv32-dijkstra_large.opt.bc -o rv32-dijkstra_large.s

# RISC-V needs to use GNU as/ld, as LLVM for RISC-V doesn't support assembling
# and linking yet

riscv32-unknown-elf-as -o rv32-dijkstra_large.o -c rv32-dijkstra_large.s

riscv-sbt -o rv32-x86-dijkstra_large.bc rv32-dijkstra_large.o

llvm-dis rv32-x86-dijkstra_large.bc -o rv32-x86-dijkstra_large.ll
opt -O3 rv32-x86-dijkstra_large.bc -o rv32-x86-dijkstra_large.opt.bc
llvm-dis rv32-x86-dijkstra_large.opt.bc -o rv32-x86-dijkstra_large.opt.ll

llc -relocation-model=static -O3 -march=x86 -mattr=avx2 rv32-x86-dijkstra_large.opt.bc -o rv32-x86-dijkstra_large.s

x86_64-linux-gnu-as --32 -o rv32-x86-dijkstra_large.o -c rv32-x86-dijkstra_large.s

x86_64-linux-gnu-ld -m elf_i386 -o rv32-x86-dijkstra_large /usr/lib32/crt1.o /usr/lib32/crti.o rv32-x86-dijkstra_large.o /mnt/ssd/riscv-sbt/toolchain/debug/share/riscv-sbt/x86-syscall.o /usr/lib32/libc.a /usr/lib/gcc/x86_64-linux-gnu/4.9.2/32/libgcc.a /usr/lib/gcc/x86_64-linux-gnu/4.9.2/32/libgcc_eh.a /usr/lib32/libc.a /usr/lib32/crtn.o
