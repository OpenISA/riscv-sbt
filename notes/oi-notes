===
OiCombinePass
===
- combine load large immediates - ABSENT in RISC-V STB
- combine GEP+ShadowMemory - ABSENT


===
OiInstTranslate
===
- FinishFunction
    - IREmitter: CleanRegs, FixEntryBB, FixBBTerminators
    - ABSENT
- FinishModule
    - IREmitter::ProcessIndirectJumps
    - ABSENT
- HandleAluSrcOperand
    - Reg: load from local, mark as read
    - Imm: resolve relocation. Handle function address
    SBT:
    - MAYBE need to mark as read as well?
    - TODO better handling of function address
- HandleMemOperand
    - resolve relocation and map to shadow memory
    - DONE
- HandleAluDstOperand
    - get reg and mark as written
    - MAYBE
- HandleCallTarget
    - IREmitter::HandleLocalCall
    - OR handle libc call
    - DONE
- HandleBranchTarget
    - set target address and create BB
    - DONE
- printInstruction - main method
    - handle operands
    - add first instruction to map
    - JUMP: br
    - BRANCH: cond br
    - JAL: HandleCallTarget (IREmmiter::HandleLocalCall)
    - JALR: IREmmiter: HandleFunctionExitPoint/AddIndirectCall/HandleFunctionEntryPoint
    - IJMP: IREmmiter: AddIndirectJump to a dummy instruction
    - DONE


===
OiIREmitter
===
AbiLocals - save only those regs required by the ABI
NoLocals - use global variables only
OneRegion - whole program in one function
OptimizeStack
AggrOptimizeStack
NoShadow - avoid adding shadow image offset to every memory access

- CleanRegs - seems to remove unused loads/stores to registers that are not
used, but that the compiler can't optimize out.
- MAYBE check if needed

- ProcessIndirectJumps
    - for each relocation in .text:
        - offset = rel.offset + PatchedSecAddr
        - TargetAddr = rel.sym.addr + ShadowImage[offset] + TextOffset
        - CodePtrs.insert(TargetAddr)
        - if TargetAddr matches function addr: add patch: offset,
                                                          BB[TargetAddr]
        - IndDests.add(BB)
        - IndDestsAddrs.add(TargetAddr)

    - for each indirect jump:
        - try to find a jump table:
            - found: create a switch with possible destinations
            - not found: indirect br to all possible BBs in function
              (IndDests)

    - for each indirect call: call through pointer
- TODO need to implement this on SBT

- StartFunction
    - build local reg file
    - TODO need to implement local reg file
- StartMainFunction
    - InsertStartupCode
    - DONE in parts
- HandleFunctionEntryPoint - sync local reg file with global one
    - TODO need to implement this
- HandleFunctionExitPoint - sync global reg file with local one
    - TODO need to implement this
- FixEntryBB - fix function entry point, to the one with no predecessors
    - MAYBE is this needed on SBT?
- FixBBTerminators
    - CreateUnreachable on BBs with no terminators
    - erase empty BBs
    - MAYBE is this needed on SBT?
- BuildReturns
    - on function returns, create an indirect br, with call sites as
      possible destinations
    - MAYBE is this needed? SBT uses LLVM return on most cases
- HandleBackEdge
    - get back BB, possibly splitting an existing one
    - DONE


===
RelocationReader
===

Resolves relocations

- ResolveAllDataRelocations
    - for all relocations pointing to .data:
        - replace the value pointing to data by:
            - common symbol value, if relocation name matches the name of a
              common symbol:
                - BSS: symbol value = ELF symbol address
                - common: symbol value = current TotalSize, that is
                                         incremented next
                - IREmitter: adjusts every common symbol:
                    - value += CommonSectionAddress
                    - (CommonSectionAddress = ShadowSize)
            - other symbols: add section address to original symbol's address
    - .text relocations are performed by ProcessIndirectJumps

    - DONE seems to be done on SBT

===
SBTUtils
===

Convert register numbers from LLVM to OpenISA and vice-versa
- DONE

- GetELFOffset(section): get offset of section inside the ELF image
    - DONE
- GetCommonSymbolsList: get all .bss and common symbols from ELF object
    - DONE in another way


===
StringRefMemoryObject
===

Convenience class to extract bytes from a StringRef
- probably unneeded


===
SyscallsIface
===

Generate code to call libc functions.
- DONE in another way


===
staticbt
===

StackSize - default = 300B

- OptimizeAndWriteBitcode
    - createVerifierPass
    - createPromoteMemoryToRegisterPass
    - new OiCombinePass
    - createInstructionCombiningPass
    - createGVNPass
    - createCFGSimplificationPass
    - WriteBitcodeToFile
    - MAYBE need to optimize in SBT

- DisassembleObject
    - get target, its disassembler, reg info, asm info, etc...
    - create a new OiInstTranslate obj
    - for each text section:
        - read section symbols
        - for each symbol:
            - create a new function, beginning at symbol address and ending at
              the next symbol
            - for each instruction:
                - disassemble it
                - translate it (using OiInstTranlate)
    - OptimizeAndWriteBitcode
    - TODO translate multiple objects

- DumpObject
    - prints some stuff and calls DisassembleObject

- DumpArchive
    - iterate through each contained object calling DumpObject on each

- DumpInput
    - read file and call DumpArchive or DumpObject

- main
    - init LLVM targets
    - parse command line
    - for each input file:
        - call DumpInput


===
openisa
===

build.sh:
    - build binutils + LLVM OpenISA + newlib
    - download SPEC
    - download ARM cross-compiler
    - install SPEC and ARM compiler
    - build mibench (build_all_x86.sh)
    - build SPEC (build_all_x86.sh)

run.sh:
    - source env.sh
    - cd openisa/spec/testes-x86/measure_x86.sh

mibench/build_all_x86.sh:
    - for each selected benchmark:
        - cd to bench dir
        - for opts in -oneregion, -nolocals, (locals), -abi-locals:
            - skip cjpeg and djpeg in -oneregion mode
            - SBTOPT="-optimize $opts" make
            - copy binaries to testes-x86/bin
